// CMC -- OpenGL Graphics for QCN project
// (c) 2007 Stanford University

#ifdef _WIN32
#include "boinc_win.h"
#else
#include <math.h>
#endif

#include "reduce.h"  // boinc includes -- reduce, parse -- parses xml files, util & gutil & gl & graphics stuff etc
#include "parse.h"
#include "util.h"
#include "gutil.h"
#include "boinc_gl.h"
#include "app_ipc.h"
#include "boinc_api.h"
#include "graphics2.h"
#include "txf_util.h"
#include "qcn_shmem.h"
#include "qcn_graphics.h"
#include "qcn_earth.h"

using std::string;
using std::vector;

CQCNShMem* sm = NULL;

float aryg[4][PLOT_ARRAY_SIZE];

vector<SQuake> vsq; // a vector of earthquake data struct (see qcn_graphics.h)

CEarth earth; // make a global earth object from the qcn_earth.cpp stuff

bool bFullScreen = false;
bool bResetArray = true;

// an array of x/y/z for screensaver moving
GLfloat jiggle[3] = {0., 0., 0.};

GLfloat white[4] = {1., 1., 1., 1.};
GLfloat red[4] = {1., 0., 0., 1.};
GLfloat green[4] = {0., 1., 0., 1.};
GLfloat yellow[4] = {1., 1., 0., 1.};
GLfloat blue[4] = {0., 0., 1., 1.};
GLfloat purple[4] = {1., 0., 1., 1.};
GLfloat dark_blue[4] = {  1.0f/255.f,   1.0f/255.f, 101.0f/255.f, 1.0f};
GLfloat dark_green[4] = { 32.0f/255.f, 101.0f/255.f,   8.0f/255.f, 1.0f};
GLfloat black[4] = {0., 0., 0., 0.};
GLfloat trans_red[4] = {1., 0., 0., .5};
GLfloat trans_yellow[4] = {1., 1., 0., .5};

GLfloat* colorsPlot[4] = { green, yellow, blue, red };
const float xax[2] = { -10.0, 40.0 };
const float yax[4] = { -29.0, -13.0, 8.0, 21.0 };

double dtw[2]; // time window
long int lOffsetOld = 0L;

// an hour seems to be the max to vis without much delay
long int awinsize[MAX_KEY_WINSIZE+1]; 
int key_winsize = 0; // points to an element of the above array to get the winsize (# of dt points i.e. 100 = 10 sec 600 = minute, 36000 = hour)
int key_press = 0;
int key_press_alt = 0;
int key_up = 0;
int key_up_alt = 0;

//e_view eView = VIEW_EARTH; //VIEW_PLOT;
e_view eView = VIEW_PLOT;

long int lSnapshotPoint = 0;
bool bSnapshot = false;
bool bScale = false;
bool b2D = false;

int width, height;      // window dimensions
APP_INIT_DATA qcn_aid;
bool mouse_down = false;
int mouseX, mouseY;
int mouseSX, mouseSY;

// save this per view i.e. VIEW_PLOT=0  VIEW_EARTH=1
double pitch_angle[2] = {0.0, 0.0}, roll_angle[2] = {0.0, 0.0}, viewpoint_distance[2]={ 10.0, 10.0};
float color[4] = {.7, .2, .5, 1};

TEXTURE_DESC logo;  // customized version of the boinc/api/gutil.h TEXTURE_DESC
RIBBON_GRAPH rgx, rgy, rgz, rgs; // override the standard boinc/api ribbon graph draw as it's making the earth red!

void getSharedMemory(char* strFile = NULL)
{
        if (sm) return; // already setup?
        sm = (CQCNShMem*) boinc_graphics_get_shmem(QCN_SHMEM);
        if (!sm) {
               fprintf(stdout, "Could not read QCN shared memory for graphics!\n");
        }
        if (sm && strFile && strFile[0] != 0x00) {
               strcpy((char*) sm->strCurFile, strFile);
               sm->deserialize(sm, sizeof(CQCNShMem), (const char*) sm->strCurFile);
               sm->bReadOnly = true; // put this in readonly mode
               fprintf(stdout, "QCN memory read from file %s\n", sm->strCurFile);
        }
}

void dtime_to_print(const double dtime, char* strTime)
{ // this sets strTime to a character string of UTC time from the given double, strTime at least 26 chars!

    if (dtime <= 0) { // if time not set
        sprintf(strTime, "N/A");
        return;
    }

    struct tm tmp;
    time_t tt = (time_t) dtime;  // note that this truncates the microseconds i.e. decimal part of dtime   
    gmtime_r(&tt, &tmp);

    // print out as month/day/year hour:min:sec
    sprintf(strTime, "%02d/%02d/%04d %02d:%02d:%02d", 
       tmp.tm_mon, tmp.tm_mday, tmp.tm_year+1900, 
       tmp.tm_hour, tmp.tm_min, tmp.tm_sec);  // don't need microseconds! , dtime - (double) tt);
}

void set_viewpoint(double dist) {
    double x, y, z;
    x = 0.0;
    y = (bScale ? 0.0 : 3.0*dist); // note if in scaled i.e. pseudo-2D mode don't shift the Y axis
    z = 11.0*dist;

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    gluLookAt(
          x, y, z,        // eye position
          0,-.8,0,        // where we're looking
          0.0, 1.0, 0.    // up is in positive Y direction
    );

    if (!bScale) { // don't pitch or roll on the 2d view
      glRotated(pitch_angle[eView], 1., 0., 0);
      glRotated(roll_angle[eView], 0., 1., 0);    
    }
}

void init_camera(double dist) {
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(
        45.0,       // field of view in degree
        1.0,        // aspect ratio
        1.0,        // Z near clip
        1000.0      // Z far
    );
    set_viewpoint(dist);

/* frm earth InitCamera
        glMatrixMode(GL_PROJECTION);
        glLoadIdentity();
        // orthographic projection
        glOrtho(-2.8, 2.8, -2.05, 2.05, -10, 10.0);
        glMatrixMode(GL_MODELVIEW);
        glLoadIdentity();
        SetViewpoint();
*/

}

// set up lighting model
//
void init_lights() 
{
   GLfloat posl0[4] = {-13.0, 6.0, 20.0, 1.0};
   GLfloat dir[] = {-1, -.5, -3, 1.0};

   GLfloat ambient[] = {.2, .2, .2, 1.0};
   GLfloat diffuse[] = {.8, .8, .8, 1.0};
   GLfloat specular[]= {.0, .0, .0, 1.0};

   GLfloat shine = 1.f;
   GLfloat attenuation = 1.f;

   glEnable(GL_LIGHTING);
   glEnable(GL_LIGHT0);

   glLightfv(GL_LIGHT0, GL_POSITION, posl0);
   
   glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);

   glLightfv(GL_LIGHT0, GL_SPOT_DIRECTION, dir);
   glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
   glLightfv(GL_LIGHT0, GL_SPECULAR, specular);

   glLightfv(GL_LIGHT0, GL_CONSTANT_ATTENUATION, &attenuation);
   glMaterialfv(GL_FRONT, GL_SHININESS, &shine);

   // no two-sided polygons
   glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_FALSE);

   // local viewer for specular light?
   glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE);

   // enable smoooth shading (multi-coloured polygons)
   glShadeModel(GL_SMOOTH);

   // fill polygons
   glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

   glEnable(GL_DEPTH_TEST);
}

void draw_logo() {
    if (logo.present) {
        float pos[3] = {0.0, .5, 0};
        float size[3] = {.21, .21, 0};
        logo.draw(pos, size, ALIGN_CENTER, ALIGN_CENTER);
    }
}

void draw_text_user() 
{   if (!sm) {
       txf_render_string(.1, 0, 0, 0, 800, red, 0, "No shared memory, QCN not running?");
       return;
    }

    char buf[256];
    double fd = 0, cpu=0;

/*
    sprintf(buf, "mouse x=%d  y=%d", mouseSX, mouseSY);
    txf_render_string(.1, 0, .04, 0, MSG_SIZE_NORMAL, red, 0, buf);
*/

    // user info
    //sprintf(buf, "%s", qcn_aid.user_name);
    txf_render_string(.1, 0, .10, 0, MSG_SIZE_NORMAL, white, 0, qcn_aid.user_name);

    //sprintf(buf, "Team: %s", qcn_aid.team_name);
    txf_render_string(.1, 0, 0.08, 0, MSG_SIZE_NORMAL, white, 0, qcn_aid.team_name);

    fd = sm->fraction_done;
    cpu = sm->cpu_time;

    sprintf(buf, "CPU Time: %f sec", cpu);
    txf_render_string(.05, 0, 0.05, 0, MSG_SIZE_NORMAL, white, 0, buf);

	
#ifdef KEYVIEW
    sprintf(buf, "keys:  dn %d  %d  up %d %d", key_press, key_press_alt, key_up, key_up_alt);
    txf_render_string(.1, 0, 0, 0, 800, red, .6, buf);
#endif

    if (sm) {
        if (dtime()-sm->update_time > 5) {
            txf_render_string(.1, 0, 0, 0, 800, red, 0, "QCN not running");
        } else if (sm->status.suspended) {
            txf_render_string(.1, 0, 0, 0, 800, red, 0, "QCN suspended");
        }

/*   
    //CMC -- for debugging:
        sprintf(buf, "Current=%ld   Snapshot=%ld", sm->lOffset, lSnapshotPoint);
        txf_render_string(.05, 0.0, y+.16, 0, 1000, white, 0, buf);

        sprintf(buf, "Sample Size: %ld", sm->lSampleSize);
        txf_render_string(.05, x, y+.08, 0, MSG_SIZE_SMALL, white, 0, buf);
     
        sprintf(buf, "CPU: %f,  st=%c, key = %d,  winsize = %ld sec", cpu, bSnapshot ? 'Y' : 'N', key_press, awinsize[key_winsize]/10); 
        txf_render_string(.05, x, y, 0, 3000, white, 0, buf);
       
       
        if (eView == VIEW_PLOT)  {
            sprintf(buf, "AVG: x=%6.2f y=%6.2f z=%6.2f sig=%6.2f", sm->xa[lSnapshotPoint], sm->ya[lSnapshotPoint], sm->za[lSnapshotPoint], sm->fsig[lSnapshotPoint]); 
            txf_render_string(.05, x, y+.32, 0, 750, white, 0, buf);
            sprintf(buf, "SNP: x=%6.2f y=%6.2f z=%6.2f sig=%6.2f", sm->x0[lSnapshotPoint], sm->y0[lSnapshotPoint], sm->z0[lSnapshotPoint], sm->fsig[lSnapshotPoint]); 
            txf_render_string(.05, x, y+.24, 0, 500, white, 0, buf);
        }
        else {
            sprintf(buf, "AVG: x=%6.2f y=%6.2f z=%6.2f sig=%6.2f", sm->xa[sm->lOffset], sm->ya[sm->lOffset], sm->za[sm->lOffset], sm->fsig[sm->lOffset]); 
            txf_render_string(.05, x, y+.32, 0, 750, white, 0, buf);
            sprintf(buf, "CUR: x=%6.2f y=%6.2f z=%6.2f sig=%6.2f", sm->x0[sm->lOffset], sm->y0[sm->lOffset], sm->z0[sm->lOffset], sm->fsig[sm->lOffset]); 
            txf_render_string(.05, x, y+.24, 0, 500, white, 0, buf);
        }
*/
    } 
    else {  // no shared memory
        txf_render_string(.1, 0, 0, 0, MSG_SIZE_NORMAL, red, 0, "No shared memory!");
    }

}

void draw_text_plot() 
{  // this draws the seismic sensor/accelerometer labels
    char buf[256];

   // the following uncommented out will let the text bounce around!
    //static float x=0, y=0;
    //static float dx=0.0003, dy=0.0007;
    //x += dx;
    //y += dy;
    //if (x < 0 || x > .5) dx *= -1;
    //if (y < 0 || y > .5) dy *= -1;

    // left of window informative text

    // help messages
     if (!bFullScreen) {
 	if (bSnapshot)  {
		sprintf(buf, "Press 'S' for live view"); 
		txf_render_string(.1, 0, .4, 0, MSG_SIZE_NORMAL, yellow, 0, buf);
		sprintf(buf, "Use '<' & '>' keys to pan");
		txf_render_string(.1, 0, .35, 0, MSG_SIZE_NORMAL, yellow, 0, buf);
	}
	else {
		sprintf(buf, "Press 'S' for snapshot view"); 
		txf_render_string(.1, 0, .4, 0, MSG_SIZE_NORMAL, yellow, 0, buf);
	}

	sprintf(buf, "Press 'Q' for world earthquake map"); 
	txf_render_string(.1, 0, .32, 0, MSG_SIZE_NORMAL, yellow, 0, buf);
       
	sprintf(buf, "Press 'L' to toggle 2D/3D Plot"); 
	txf_render_string(.1, 0, .30, 0, MSG_SIZE_NORMAL, yellow, 0, buf);
       
	sprintf(buf, "Press +/- to change time window");
	txf_render_string(.1, 0, .28, 0, MSG_SIZE_NORMAL, yellow, 0, buf);
     }

	// graph labels
	sprintf(buf, "Sigma");
	txf_render_string(.05, .30, .64, 0, MSG_SIZE_MEDIUM, colorsPlot[E_DS], 0, buf);
        if (sm) {
           sprintf(buf, " max=%5.2f", sm->fmax[E_DS]);
           txf_render_string(.05, .30, .62, 0, MSG_SIZE_SMALL, colorsPlot[E_DS], 0, buf);
           sprintf(buf, " min=%5.2f", sm->fmin[E_DS]);
           txf_render_string(.05, .30, .60, 0, MSG_SIZE_SMALL, colorsPlot[E_DS], 0, buf);
        }

	sprintf(buf, "Z-amp");
	txf_render_string(.05, .30, .45, 0, MSG_SIZE_MEDIUM, colorsPlot[E_DZ], 0, buf);
        if (sm) {
           //sprintf(buf, " max=%5.2f", sm->fmax[E_DZ] < 0 ? 0.0 : sm->fmax[E_DZ]);
           sprintf(buf, " max=%5.2f", sm->fmax[E_DZ]);
           txf_render_string(.05, .30, .43, 0, MSG_SIZE_SMALL, colorsPlot[E_DZ], 0, buf);
           sprintf(buf, " min=%5.2f", sm->fmin[E_DZ]);
           txf_render_string(.05, .30, .41, 0, MSG_SIZE_SMALL, colorsPlot[E_DZ], 0, buf);
        }

	sprintf(buf, "Y-amp");
	txf_render_string(.05, .30, .24, 0, MSG_SIZE_MEDIUM, colorsPlot[E_DY], 0, buf);
        if (sm) {
           //sprintf(buf, " max=%5.2f", sm->fmax[E_DY] < 0 ? 0.0 : sm->fmax[E_DY]);
           sprintf(buf, " max=%5.2f", sm->fmax[E_DY]);
           txf_render_string(.05, .30, .22, 0, MSG_SIZE_SMALL, colorsPlot[E_DY], 0, buf);
           sprintf(buf, " min=%5.2f", sm->fmin[E_DY]);
           txf_render_string(.05, .30, .20, 0, MSG_SIZE_SMALL, colorsPlot[E_DY], 0, buf);
        }

	sprintf(buf, "X-amp");
	txf_render_string(.05, .30, .08, 0, MSG_SIZE_MEDIUM, colorsPlot[E_DX], 0, buf);
        if (sm) {
           //sprintf(buf, " max=%5.2f", sm->fmax[E_DX] < 0 ? 0.0 : sm->fmax[E_DX]);
           sprintf(buf, " max=%5.2f", sm->fmax[E_DX]);
           txf_render_string(.05, .30, .06, 0, MSG_SIZE_SMALL, colorsPlot[E_DX], 0, buf);
           sprintf(buf, " min=%5.2f", sm->fmin[E_DX]);
           txf_render_string(.05, .30, .04, 0, MSG_SIZE_SMALL, colorsPlot[E_DX], 0, buf);
        }

        // set time points 
        char strt[2][32];
        memset(strt, 0x00, sizeof(char) * 64);
        dtime_to_print((const double) dtw[0], strt[0]);
        dtime_to_print((const double) dtw[1], strt[1]);

        switch(key_winsize) {
          case 0:
             sprintf(buf, "Window Width = 1 minute");
             break;
          case 1:
             sprintf(buf, "Window Width = 10 minutes");
             break;
          case 2:
             sprintf(buf, "Window Width = 1 hour");
             break;
          case 3:
             sprintf(buf, "Window Width = 4 hours");
             break;
        }
        txf_render_string(.1, 0, 0.21, 0, 1500, white, 0, buf);

        sprintf(buf, "Window Start Time = %s", strt[0]);
        txf_render_string(.1, 0, 0.18, 0, 1500, white, 0, buf);
        sprintf(buf, "Window End Time   = %s", strt[1]);
        txf_render_string(.1, 0, 0.15, 0, 1500, white, 0, buf);

}

// note the reference to the pointer arrays
bool setupPlotMemory()  // float*& ddx, float*& ddy, float*& ddz, float*& dds)
{
    int iRebin;
    float fAvg[4];
    switch(key_winsize) {
      case 0: // 1 minute = 3000 pts, if PLOT_ARRAY_SIZE=1000 we avg 3 points to 1
         iRebin = (int) (60.0 / sm->dt) / PLOT_ARRAY_SIZE;
         break;
      case 1: // 10 minutes = 30000 pts
         iRebin = (int) (600.0 / sm->dt) / PLOT_ARRAY_SIZE;
        break;
      case 2: // 1 hour = 180000 pts 
         iRebin = (int) (3600.0 / sm->dt) / PLOT_ARRAY_SIZE;
         break;
      default:  iRebin = 10;
    }
  
    long int lOff;
    if (bSnapshot) { // use a "non-floating" time point, ie. when they hit the S key to toggle the static/snapshot view
      lOff = lSnapshotPoint - awinsize[key_winsize];
      // set timestamps for window to be displayed in the draw_text
      dtw[1] = sm->t0[lSnapshotPoint];  // timestamp for end of the window (which is the current snapshot point)
      bResetArray = true;
    }
    else {
      lOff = sm->lOffset - awinsize[key_winsize];
      // set timestamps for window to be displayed in the draw_text
      dtw[1] = sm->t0[sm->lOffset];   // timestamp for end of the window (which is the current point)
    }
    earth.SetTime(dtw[1]);

    // if bNewPoint is true, and bResetArray is not true, we can use the array as is, just shifting over to get the last rebin point data
    bool bNewPoint = sm->lOffset > (lOffsetOld + iRebin); // it's a new point req to be drawn if we have increased past our "rebin" size
    if (bNewPoint || bResetArray) lOffsetOld = sm->lOffset; // set this new point/offset for the next bNewPoint trigger

    if (sm->lOffset < lOffsetOld) { // must have wrapped around the array (i.e. over an hour), so better reset array
       bResetArray = true;
       lOffsetOld = sm->lOffset; 
    }

    float *af[4] = {NULL,NULL,NULL,NULL};
    for (int i = 0; i < 4; i++) {
      af[i] = new float[awinsize[key_winsize]];
    }

    if (!af[E_DX] || !af[E_DY] || !af[E_DZ] || !af[E_DS] ) {
      if (af[E_DX]) delete [] af[E_DX];
      if (af[E_DY]) delete [] af[E_DY];
      if (af[E_DZ]) delete [] af[E_DZ];
      if (af[E_DS]) delete [] af[E_DS];
      return false;
    }

    for (int i = 0; i < 4; i++) {
      memset(af[i], 0x00, sizeof(float) * awinsize[key_winsize]);
      // reset array if desired
      if (bResetArray) memset(aryg[i], 0x00, sizeof(float) * PLOT_ARRAY_SIZE);
    }

    if (lOff > 0)  {  // all points exist in our window, so we can just go into lOffset - winsize and copy/scale from there
      dtw[0] = sm->t0[lOff];  // this will be the timestamp for the beginning of the window, i.e. "awinsize[key_winsize] ticks ago"

      for (long int i = 0; i < awinsize[key_winsize]; i++) { // note we're scaling to get between 0 & 1 each value
        if (bScale) {
          af[E_DX][i] = sm->x0[lOff]; 
          af[E_DY][i] = sm->y0[lOff]; 
          af[E_DZ][i] = sm->z0[lOff]; 
          //af[E_DX][i] = (sm->x0[lOff] - sm->fmin[E_DX]) / (sm->fmax[E_DX] - sm->fmin[E_DX]);
          //af[E_DY][i] = (sm->y0[lOff] - sm->fmin[E_DY]) / (sm->fmax[E_DY] - sm->fmin[E_DY]);
          //af[E_DZ][i] = (sm->z0[lOff] - sm->fmin[E_DZ]) / (sm->fmax[E_DZ] - sm->fmin[E_DZ]);
        }
        else {
          af[E_DX][i] = sm->x0[lOff] - sm->xa[lOff];   // (sm->xa[lOff] - sm->fmin[E_DX]) / (sm->fmax[E_DX] - sm->fmin[E_DX]);
          af[E_DY][i] = sm->y0[lOff] - sm->ya[lOff];   // (sm->ya[lOff] - sm->fmin[E_DY]) / (sm->fmax[E_DY] - sm->fmin[E_DY]);
          af[E_DZ][i] = sm->z0[lOff] - sm->za[lOff];   // (sm->za[lOff] - sm->fmin[E_DZ]) / (sm->fmax[E_DZ] - sm->fmin[E_DZ]);
        }
        af[E_DS][i] = lOff < (long int)(60.0/sm->dt) ? 0.0 : sm->fsig[lOff]; // don't show fsig pts within first minute
        lOff++;
      }
    }
    else { // we are wrapping around the array
      long int lStart = MAXI + lOff - 1;   // start here, wrap around to 1+(awinsize-lStart) (skip 0 as that's baseline?)
      dtw[0] = sm->t0[lStart+1];  // this will be the timestamp for the beginning of the window, i.e. "awinsize[key_winsize] ticks ago"
      for (long int i = 0; i < awinsize[key_winsize]; i++) {
        lStart++;
        if (lStart == MAXI || lStart == 0) lStart = 1;
 
        if (bScale) {
            af[E_DX][i] = sm->x0[lStart]; 
            af[E_DY][i] = sm->y0[lStart];
            af[E_DZ][i] = sm->z0[lStart]; 
        }
        else {
          // now we can scale each axis according to fmin = 0 and fmax = 1
          af[E_DX][i] = sm->x0[lStart] - sm->xa[lStart];   // (sm->xa[lStart] - sm->fmin[E_DX]) / (sm->fmax[E_DX] - sm->fmin[E_DX]);
          af[E_DY][i] = sm->y0[lStart] - sm->ya[lStart];   // (sm->ya[lStart] - sm->fmin[E_DY]) / (sm->fmax[E_DY] - sm->fmin[E_DY]);
          af[E_DZ][i] = sm->z0[lStart] - sm->za[lStart];   // (sm->za[lStart] - sm->fmin[E_DZ]) / (sm->fmax[E_DZ] - sm->fmin[E_DZ]);
        }
        af[E_DS][i] = lStart < (long int)(60.0/sm->dt) ? 0.0 : sm->fsig[lStart]; // don't show fsig pts within first minute 
      }
    }

    if (bResetArray) { // we need to rebin the whole array, perhaps we changed window view or are in snapshot view

      // now try a simple averaging rebinning to get the array down to manageable size (1000 pts)
      for (long int i = 0; i < awinsize[key_winsize]/iRebin; i++) {
         fAvg[E_DX] = fAvg[E_DY] = fAvg[E_DZ] = fAvg[E_DS]  = 0.0;
         for (int j = 0; j < iRebin; j++) {
             fAvg[E_DX] += af[E_DX][(i*iRebin)+j];
             fAvg[E_DY] += af[E_DY][(i*iRebin)+j];
             fAvg[E_DZ] += af[E_DZ][(i*iRebin)+j];
             fAvg[E_DS] += af[E_DS][(i*iRebin)+j];
         }
         aryg[E_DX][i] = fAvg[E_DX] / (float) iRebin;
         aryg[E_DY][i] = fAvg[E_DY] / (float) iRebin;
         aryg[E_DZ][i] = fAvg[E_DZ] / (float) iRebin;
         aryg[E_DS][i] = fAvg[E_DS] / (float) iRebin;
      }

      bResetArray = false; 

    } // bResetArray
    else { // !bResetArray -- just push on the last point if required
      // see if our last point is "outdated" and we need to shift the array over and add a new point
      if (bNewPoint) {  // this was set at the top of this function

         // just get the last iRebin elements, average them, and pop at the end of the array
         float *tempary = new float[PLOT_ARRAY_SIZE];
         for (int i = 0; tempary && i < 4; i++)  {
           memset(tempary, 0x00, sizeof(float) * PLOT_ARRAY_SIZE);

           // copy a "shifted over" array, i.e. drops the first element so we can add a last element
           memcpy(tempary, aryg[i]+1, sizeof(float) * (PLOT_ARRAY_SIZE-1));

           // now we need to set the last element of tempary, so get the last iRebin elements and average them
           fAvg[i] = 0.0f;
           for (long int j = awinsize[key_winsize] - iRebin; j < awinsize[key_winsize]; j++) {
               fAvg[i] += af[i][j];
           }
           tempary[PLOT_ARRAY_SIZE-1] = fAvg[i] / (float) iRebin;

           // now copy the entire array back 
           memcpy(aryg[i], tempary, sizeof(float) * PLOT_ARRAY_SIZE);
         }
         if (tempary) delete [] tempary;
      }
   }

   if (af[E_DX]) delete [] af[E_DX];
   if (af[E_DY]) delete [] af[E_DY];
   if (af[E_DZ]) delete [] af[E_DZ];
   if (af[E_DS]) delete [] af[E_DS];
   
   return true;
}

void draw_plots_2d() 
{
    if (!sm) return; // not much point in continuing if shmem isn't setup!
    if (! setupPlotMemory() ) return; // error in setting up array data

    init_camera(viewpoint_distance[eView]);
    init_lights();
    scale_screen(width, height);

    // should just be simple draw each graph in 2D using the info in dx/dy/dz/ds?
    
    float fmin, fmax;
    float* fdata = NULL;

    glPushMatrix();
    mode_unshaded();
    for (int ee = E_DX; ee <= E_DS; ee++)  {
         //mode_shaded((float*) colorsPlot[ee]);
         glColor4fv((GLfloat*) colorsPlot[ee]);

         switch(ee) {
            case E_DX:  fdata = aryg[E_DX]; break;
            case E_DY:  fdata = aryg[E_DY]; break;
            case E_DZ:  fdata = aryg[E_DZ]; break;
            case E_DS:  fdata = aryg[E_DS]; break;
         }

         // first draw the axes
         glLineWidth(2);
         glBegin(GL_LINES);
         glVertex2f(xax[0], yax[ee]);
         glVertex2f(xax[1], yax[ee]);
         glEnd();

         // now plot the data
         fmin = abs(sm->fmin[ee]);
         fmax = abs(sm->fmax[ee]);
         if (fmin > fmax) fmax = fmin;
         if (fmax == 0) fmax = 1.0;

         glLineWidth(1);
         glBegin(GL_LINE_STRIP);
         for (int i=0; i<PLOT_ARRAY_SIZE; i++) {
          if (fdata[i] != 0)
            glVertex2f(
               xax[0] + (((float) i / (float) PLOT_ARRAY_SIZE) * (xax[1]-xax[0])), 
               yax[ee] + (ee == E_DS ? fdata[i] : (8 * (fdata[i] / fmax)))
            );
         }
         glEnd();
    }
    glPopMatrix();
    
    glFlush();
}

void draw_plots_3d() 
{
    // setup arrays for the plots, as we'll have to pre-process the raw data from the sensor
    if (!sm) return; // not much point in continuing if shmem isn't setup!
    if (! setupPlotMemory() ) return; // error in setting up array data

    // use jiggle array to move around graph in x/y/z depending on values

    init_camera(viewpoint_distance[eView]);

    if (bFullScreen) { // probably just do this in screensaver mode?
      jiggle[E_DX] = aryg[E_DX][PLOT_ARRAY_SIZE-1];
      jiggle[E_DY] = aryg[E_DY][PLOT_ARRAY_SIZE-1];
      jiggle[E_DZ] = aryg[E_DZ][PLOT_ARRAY_SIZE-1];
      glRotated(jiggle[E_DX], 1., 0., 0.);
      glRotated(jiggle[E_DY], 0., 1., 0.);
      glRotated(jiggle[E_DZ], 0., 0., 1.);
    }

    init_lights();
    scale_screen(width, height);

    rgx.draw(aryg[E_DX], PLOT_ARRAY_SIZE, false);
    rgy.draw(aryg[E_DY], PLOT_ARRAY_SIZE, false);
    rgz.draw(aryg[E_DZ], PLOT_ARRAY_SIZE, false);
    rgs.draw(aryg[E_DS], PLOT_ARRAY_SIZE, false);

    /* TODO -- get plot labels in the 3d camera view/
    // graph labels
    char buf[8];
    sprintf(buf, "Sigma");
    txf_render_string(.05, -10.0, -32.0, 0.0, 1500, colorsPlot[E_DS], 0, buf);

    sprintf(buf, "Z-amp");
    txf_render_string(.05, -10.0, -28.0, 0.0, 1500, colorsPlot[E_DZ], 0, buf);

    sprintf(buf, "Y-amp");
    txf_render_string(.05, -10.0, -24.0, 0.0, 1500, colorsPlot[E_DY], 0, buf);

    sprintf(buf, "X-amp");
    txf_render_string(.05, -10.0, -21.0, 0.0, 1500, colorsPlot[E_DX], 0, buf);
    */
}

void app_graphics_render(int xs, int ys, double time_of_day) {
    // boinc_graphics_get_shmem() must be called after 
    // boinc_parse_init_data_file()
    // Put this in the main loop to allow retries if the 
    // worker application has not yet created shared memory
    //
    static bool bInHere = false;

    if (bInHere) return; // currently rendering

    if (!sm) {
        getSharedMemory();
    }

    bInHere = true;

    // from here on is the plots
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // draw logo first - it's in background
    //
    mode_unshaded();
    mode_ortho();
    draw_logo();
    ortho_done();

    if (eView == VIEW_EARTH) {    
       earth.DrawScene(width, height, viewpoint_distance[eView], pitch_angle[eView], roll_angle[eView]);
    }
    else {
       if (b2D) 
           draw_plots_2d();
       else 
           draw_plots_3d();
    }

    // draw text on top
    //
    mode_unshaded();
    mode_ortho();
    if (eView == VIEW_EARTH) {    
       earth.DrawText();
    }
    else {
       draw_text_plot();
    }
    draw_text_user();
    ortho_done();

    glFinish();
    //glutSwapBuffers();

    bInHere = false;
}

void app_graphics_resize(int w, int h)
{
    width = w;
    height = h;

    glViewport(0, 0, w, h);
    if (eView==VIEW_EARTH) {
        earth.Resize(width, height);
    }
}

// mouse drag w/ left button rotates 3D objects;
// mouse draw w/ right button zooms 3D objects
//
void boinc_app_mouse_move(int x, int y, int left, int middle, int right) 
{
    mouseSX = x;
    mouseSY = y;
    if (eView == VIEW_EARTH)  {
      earth.MouseMotion(x, y, left, middle, right);
    }
    else {
      if (left) {
          pitch_angle[eView] += (y-mouseY)*.1;
          roll_angle[eView] += (x-mouseX)*.1;
          mouseX = x;
          mouseY = y;
      } else if (right) {
          double d = (y-mouseY);
          viewpoint_distance[eView] *= exp(d/100.);
          mouseX = x;
          mouseY = y;
      } else {
          mouse_down = false;
      }
    }
}

void boinc_app_mouse_button(int x, int y, int which, int is_down) {
    mouseX = x;
    mouseY = y;

    if (eView == VIEW_EARTH)  {
      earth.MouseButton(x, y, which, is_down);
    }
    else {
        mouse_down = is_down ? true : false;
        if (mouse_down) {  // save coords when mouse down
          mouseX = x;
          mouseY = y;
        }
    }
}

void boinc_app_key_press(int k1, int k2)
{ // 27=esc  81/113 = Q, 83/115 = S, 52 = left arrow, 54 = right arrow, 45 = minus, 61 = plus
   key_press = k1;
   key_press_alt = k2;

   if (key_press == 27) { // quit on escape key
#ifdef __APPLE_CC__
          _exit(0);
#else
          _exit(0);
#endif
   }

   if (key_press == 'q' || key_press == 'Q') {
        // hit Q so toggle earth view/recent quake display
        if (eView == VIEW_PLOT) {
            eView = VIEW_EARTH;
        }
        else {
            eView = VIEW_PLOT;
        }
   }

   if (eView == VIEW_EARTH)  { 
       earth.KeyPress(key_press, key_press_alt);
       return;
   }

   switch(k1) 
   { 
/*
      case 'W':
      case 'w':
      case GLUT_KEY_F5:
           if (sm) {
             sprintf((char*)sm->strCurFile, "qcn_%lld.smz", (long long int) sm->t0[sm->lOffset]);
             if (sm->serialize(sm, sizeof(CQCNShMem), (const char*) sm->strCurFile))
                fprintf(stdout, "QCN memory written to file %s\n", sm->strCurFile);
             else
                fprintf(stdout, "Error: QCN memory NOT written to file %s\n", sm->strCurFile);
           }
           break;
      case 'R':
      case 'r':
      case GLUT_KEY_F6:
           if (sm) {
             if (sm->strCurFile[0] != 0x00) {
                 if (sm->deserialize(sm, sizeof(CQCNShMem), (const char*) sm->strCurFile)) {
                    sm->bReadOnly = true; // mark shared mem for readonly mode now
                    fprintf(stdout, "QCN memory read from file %s\n", sm->strCurFile);
                 }
                 else fprintf(stdout, "Error: QCN memory NOT read from file %s\n", sm->strCurFile);
             }
             else { 
                 fprintf(stdout, "No QCN memory file!\n");
             }
           }
           break;
*/
      case 'l':
      case 'L':  // limit (scale) the amplitude
        bScale = !bScale; 
        b2D = bScale;
        bResetArray = true;
        break;
      case 's':
      case 'S':  // hit S so toggle static display
        bSnapshot = !bSnapshot;
        if (sm && bSnapshot) lSnapshotPoint = sm->lOffset;
        if (eView == VIEW_EARTH) { // if in earth mode, send it back to regular seismic view, non-snapshot
            bSnapshot = false;
        }
        break;
      case 44:  // <
      case 60:  // ,
      case 52:  // left arrow key so move snapshot point over a winsize
        if (bSnapshot) {
          lSnapshotPoint -= (awinsize[key_winsize]+1);
          if (lSnapshotPoint < 1) lSnapshotPoint = 1;
          bResetArray = true;
        }
        break;
      case 46:  // >
      case 62:  // .
      case 54:  // right arrow key so move snapshot point over
        if (bSnapshot) {
          lSnapshotPoint += awinsize[key_winsize];
          if (sm && lSnapshotPoint > sm->lOffset) lSnapshotPoint = sm->lOffset;
          bResetArray = true;
        }
        break;
      case 45: // minus -- decrease the winsize 
        if (key_winsize > 0 ) { // not already at the minimum 
            key_winsize--;
            bResetArray = true;
        }   
        break;
      case 61: // plus 
        if (key_winsize < MAX_KEY_WINSIZE ) { // not already at the maximum
            key_winsize++;
            bResetArray = true;
        }   
        break;
   }
}

void boinc_app_key_release(int k1, int k2)
{
   key_up = k1;
   key_up_alt = k2;
   if (eView == VIEW_EARTH)  earth.KeyRelease(k1, k2);
}

void app_graphics_init() {
    char path[256];

    // setup the window widths depending on sm->dt
    if (sm) {
      awinsize[0] = (long int) (60.0/sm->dt);    // 1 minute = 60 seconds / dt // 3000 pts
      awinsize[1] = (long int) (600.0/sm->dt);   // 10 minutes = 60 seconds / dt // 30000 pts
      awinsize[2] = (long int) (3600.0/sm->dt);  // 1 minute = 60 seconds / dt // 180000 pts
      bResetArray = true;
    }    

    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);

// RIBBON GRAPH

    // setup ribbon graph stuff
    float size[3] = {50.0, 10.0, 5.0};
    float pos[3];

    pos[0] = xax[0];
    pos[1] = yax[E_DS]; 
    pos[2] = 0.0;
    rgs.init(pos, size, colorsPlot[E_DS], colorsPlot[E_DS]);

    pos[0] = xax[0];
    pos[1] = yax[E_DZ]; 
    pos[2] = 0.0;
    rgz.init(pos, size, colorsPlot[E_DZ], colorsPlot[E_DZ]);

    pos[0] = xax[0];
    pos[1] = yax[E_DY]; 
    pos[2] = 0.0;
    rgy.init(pos, size, colorsPlot[E_DY], colorsPlot[E_DY]);
 
    pos[0] = xax[0];
    pos[1] = yax[E_DX]; 
    pos[2] = 0.0;
    rgx.init(pos, size, colorsPlot[E_DX], colorsPlot[E_DX]);

    // load logo & fonts
    txf_load_fonts(".");
    boinc_resolve_filename(IMG_LOGO, path, sizeof(path));
    logo.load_image_file(path);
    init_lights();
 
    // get the CEarth object setup...
    earth.Init(); 
}

void parse_quake_info(char* strQuake, int ctr)
{
   // each line of quake info is delimited by pipe (|) char -- 5 max
   // first bit is the magnitude of the quake
   // second is the UTC time
   // third is the latitude
   // fourth is the longitude
   // fifth is the depth in km
   // sixth is a text description
 
 
   const int iMax = 7; // max # of sections
   if ((int) strlen(strQuake) <= iMax) return; // must be an error, string too short!

   const char delim = '|'; // the pipe char is the delimiter
   // search point of next delim
   char* strWhere[iMax+1] = { strQuake, NULL, NULL, NULL, NULL, NULL, NULL, strQuake+strlen(strQuake) }; 
   SQuake sq; // a temp struct to use for the vector assign
   sq.num = ctr;
   char* buf = new char[1024];

/*
5.2|2007/11/21 08:09:15          |-32.901       | -179.221 |    53.9     |SOUTH OF THE KERMADEC ISLANDS
*/

   for (int i = 1; i <= iMax; i++)  {
     if (i<iMax)
        strWhere[i] = strchr((const char*) strWhere[i-1]+1, (int) delim);	
  
     if (strWhere[i-1]) { 
        memset(buf,0x00,1024);
        strncpy(buf, strWhere[i-1] + ((i==1) ? 0 : 1), strWhere[i] - strWhere[i-1] - ((i==1) ? 0 : 1));
        //fprintf(stdout, "buf[%d] = %s\n", i, buf);

        switch (i) {
          case 1: // mag
            sq.magnitude = atof(buf);
            break;
          case 2: // time in format YYYY/MM/DD HH:MI:SS  e.g. 2007/11/21 15:05:21
            //sq.utc_time.assign(buf); 
            if (strlen(buf) < 19) break;
            char strTmp[8];
            memset(strTmp, 0x00, 8);
            strncpy(strTmp, buf, 4);
            sq.year = atoi(strTmp);

            memset(strTmp, 0x00, 8);
            strncpy(strTmp, buf+5, 2);
            sq.month = atoi(strTmp);

            memset(strTmp, 0x00, 8);
            strncpy(strTmp, buf+8, 2);
            sq.day = atoi(strTmp);

            memset(strTmp, 0x00, 8);
            strncpy(strTmp, buf+11, 2);
            sq.hour = atoi(strTmp);

            memset(strTmp, 0x00, 8);
            strncpy(strTmp, buf+14, 2);
            sq.minute = atoi(strTmp);

            memset(strTmp, 0x00, 8);
            strncpy(strTmp, buf+17, 2);
            sq.second= atoi(strTmp);
            break;
          case 3: // lat
            sq.latitude  = atof(buf);
            break;
          case 4: // lon
            sq.longitude = atof(buf);
            break;
          case 5: // depth
            sq.depth_km  = atof(buf);
            break;
          case 6: // desc
            sq.strDesc.assign(buf);
            break;
          case 7: // URL
            sq.strURL.assign(buf);
            break;
        }
     }
   }
   sq.active = false;  // not actively selected yet!

   if (sq.magnitude) { // we have magnitude, so we should add this
      vsq.push_back(sq);
   }
   delete [] buf;
}

void parse_project_prefs(char* buf) {
   // this is where we can get a list of earthquakes 
   if (!buf) return;

   int iLen = 1024; 
   char* quake = new char[iLen];
   char strTmp[16];
   int ctr = 0; 
   bool bGo = true;
   vsq.clear();
   while (bGo) {
      sprintf(strTmp, "<qu%03d>", ++ctr);
      if (parse_str(buf, strTmp, quake, iLen)) {
        //fprintf(stdout, "%s\n", quake);
        parse_quake_info(quake, ctr);
      }
      else bGo = false;
   }
   delete [] quake;

/*
   //fprintf(stdout, "Number of quakes read in = %d\n", (int) vsq.size());
   ctr=0;
   vector<SQuake>::iterator it; 
   for( it = vsq.begin(); it != vsq.end(); it++) {
      fprintf(stdout, "Quake %d: mag=%f  lat=%f  lon=%f  utc=%s  desc=%s\n",
           ++ctr, 
           it->magnitude,
           it->latitude,
           it->longitude,
           it->utc_time.c_str(),
           it->strDesc.c_str()
     );
   }

*/

}

int main(int argc, char** argv) 
{
#if (defined(__APPLE__) && defined(_DEBUG))
    // Provide a way to get error messages from system in Debug builds only. 
    // In Deployment builds, ownership violates sandbox security (unless we 
    // gave it an explicit path outside the BOINC Data directory). 
    freopen("gfx_stderr.txt", "w", stderr);
#endif
    boinc_parse_init_data_file();
    boinc_get_init_data(qcn_aid);
    if (qcn_aid.project_preferences) {
        parse_project_prefs(qcn_aid.project_preferences);
    }

    // if started with an argument, it's probably the shared mem file
    char* strFile = NULL;
    for (int i=0; i<argc; i++) {
        if (!strcmp(argv[i], "--dump") && (i+1)<argc && (argv[i+1]))
        {
            strFile = argv[i+1];
        }
        if (!strcmp(argv[i], "--fullscreen"))
        {
            bFullScreen = true;
        }
    }
    getSharedMemory(strFile);
    boinc_graphics_loop(argc, argv);
}

